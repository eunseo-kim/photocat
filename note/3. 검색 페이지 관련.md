# 3. 검색 페이지 관련

- 페이지 진입 시 포커스가 `input` 에 가도록 처리하고, 키워드를 입력한 상태에서 `input` 을 클릭할 시에는 기존에 입력되어 있던 키워드가 삭제되도록 만들어야 합니다.

  > ## 💡해결방법
  >
  > <input> 의 [`autofocus`](https://developer.mozilla.org/ko/docs/Web/HTML/Element/Input)라는  attribute를 사용했다.
  >
  > | 특성        | 유형 | 설명                                     |
  > | ----------- | ---- | ---------------------------------------- |
  > | `autofocus` | all  | 페이지가 로딩될때 양식 제어에 오토포커스 |
  >
  > ```js
  > // SearchInput.js
  > this.$searchInput.autofocus = true;
  > 
  > $searchInput.addEventListener("click", () => {
  >     $searchInput.value = "";
  > });
  > ```




- **`필수`** 데이터를 불러오는 중일 때, 현재 데이터를 불러오는 중임을 유저에게 알리는 UI를 추가해야 합니다.

  > ## 💡해결방법
  >
  > - [**loader 디자인 소스**](https://story.pxd.co.kr/922)는 여기에서 참고했다😗
  >
  > - loader을 만들어서 실행시키는 `Loader.js`를 추가하였다.
  >
  >   ```js
  >   export default class Loader {
  >     constructor($target, isLoading) {
  >       const template = `
  >           <div class="loading-wrapper">
  >               <div id="loading"></div>
  >               <p>please wait...</p>
  >           </div>
  >       `;
  >       $target.innerHTML += template;
  >       this.isLoading = isLoading;
  >       this.render();
  >     }
  >   
  >     setState(nextLoading) {
  >       this.isLoading = nextLoading;
  >       this.render();
  >     }
  >   
  >     render() {
  >       const loadingWrapper = document.querySelector(".loading-wrapper");
  >       if (this.isLoading) {
  >         loadingWrapper.style.display = "block";
  >       } else {
  >         loadingWrapper.style.display = "none";
  >       }
  >     }
  >   }
  >   ```
  >
  >   - setState에서 로딩 상태를 입력받아 `this.isLoading`에 저장하고 렌더링한다.
  >   - render에서는 `this.isLoading`의 불리언 값에 따라 미리 만들어놓은 loader의 display 속성을 할당한다. 
  >
  > - 로딩 화면이 보이는 시점은 `검색 요청 이후` ~ `화면 렌더링 이전` 까지이다.
  >
  >   따라서 `onSearch`, `onClick` 이벤트가 호출되는 즉시 바로 Loader의 `setState(true)` 함수를 호출하고, `await`가 결과를 반환한 이후에 `setState(false)` 함수를 호출하여 로더를 숨긴다.
  >
  >   ```js
  >   this.loading = new Loader($target, false);
  >   
  >   this.searchInput = new SearchInput({
  >       $target,
  >       onSearch: async (keyword) => {
  >           this.loading.setState(true); 	// 로더 실행
  >           await api.fetchCats(keyword).then(({ data }) => this.setState(data));
  >           this.loading.setState(false);	// 로더 중지
  >       },
  >   });
  >   
  >   this.searchResult = new SearchResult({
  >       $target,
  >       initialData: this.data,
  >       onClick: async (image) => {
  >           this.loading.setState(true);	// 로더 실행
  >           this.imageInfo.setState({
  >               visible: true,
  >               image: await api.fetchCatDetail(image.id),
  >           });
  >           this.loading.setState(false);	// 로더 중지
  >       },
  >   });
  >   ```

  

- **`필수`** 검색 결과가 없는 경우, 유저가 불편함을 느끼지 않도록 UI적인 적절한 처리가 필요합니다.

  > ## 💡해결방법
  >
  > 



- 최근 검색한 키워드를 `SearchInput` 아래에 표시되도록 만들고, 해당 영역에 표시된 특정 키워드를 누르면 그 키워드로 검색이 일어나도록 만듭니다. 단, 가장 최근에 검색한 5개의 키워드만 노출되도록 합니다.

  > ## 💡해결방법
  >
  > 



- 페이지를 새로고침해도 마지막 검색 결과 화면이 유지되도록 처리합니다.

  > ## 💡해결방법
  >
  > 



- **`필수`** SearchInput 옆에 버튼을 하나 배치하고, 이 버튼을 클릭할 시 `/api/cats/random50` 을 호출하여 화면에 뿌리는 기능을 추가합니다. 버튼의 이름은 마음대로 정합니다.

  > ## 💡해결방법
  >
  > .



- lazy load 개념을 이용하여, 이미지가 화면에 보여야 할 시점에 load 되도록 처리해야 합니다.

  > ## 💡해결방법
  >
  > .



- `추가` 검색 결과 각 아이템에 마우스 오버시 고양이 이름을 노출합니다.

  > ## 💡해결방법
  >
  > .



